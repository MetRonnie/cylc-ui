<!--
Copyright (C) NIWA & British Crown (Met Office) & Contributors.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<template>
  <div ref="mainDiv" class="main pa-2 fill-height">
    <!-- Lumino box panel gets inserted here -->
  </div>
  <template
    v-for="[id, { name }] in views"
    :key="id"
  >
    <Teleport :to="`#${id}`">
      <component
        :is="props.allViews.get(name).component"
        :workflow-name="workflowName"
        v-model:initial-options="views.get(id).initialOptions"
        class="h-100"
      />
    </Teleport>
  </template>
</template>

<script setup>
import {
  inject,
  nextTick,
  onBeforeUnmount,
  onMounted,
  ref,
} from 'vue'
import { useStore } from 'vuex'
import { startCase, uniqueId } from 'lodash'
import LuminoWidget from '@/components/cylc/workflow/lumino-widget'
import { BoxPanel, DockPanel, Widget } from '@lumino/widgets'
import { when } from '@/utils'
import { useDefaultView } from '@/views/views'

/*
 * A component to wrap the Lumino application.
 *
 * It will create a BoxPanel (left to right, no gutters) with a dock
 * panel. Each component/view is teleported into the Lumino widget div.
 *
 * Lumino uses DOM, and Vue the VDOM. So this is an approach that
 * works, but there could be alternative approaches too.
 */

/**
 * Mitt event for adding a view to the workspace.
 * @typedef {Object} AddViewEvent
 * @property {string} name - the view to add
 * @property {Record<string,*>} initialOptions - prop passed to the view component
 */

const $eventBus = inject('eventBus')
const $store = useStore()

const props = defineProps({
  workflowName: {
    type: String,
    required: true
  },
  /**
   * All possible view component classes that can be rendered
   *
   * @type {Map<string, import('@/views/views').CylcView>}
   */
  allViews: {
    type: Map,
    required: true
  },
})

const emit = defineEmits([
  'emptied'
])

/**
 * Template ref
 * @type {import('vue').Ref<HTMLElement>}
 */
const mainDiv = ref(null)

/**
 * Mapping of widget ID to the name of view component and its initialOptions prop.
 *
 * @type {import('vue').Ref<Map<string, AddViewEvent>>}
 */
const views = ref(new Map())

const defaultView = useDefaultView()

// create a box panel, which holds the dock panel, and controls its layout
const boxPanel = new BoxPanel({ direction: 'left-to-right', spacing: 0 })
// create dock panel, which holds the widgets
const dockPanel = new DockPanel()
boxPanel.addWidget(dockPanel)
BoxPanel.setStretch(dockPanel, 1)

const resizeObserver = new ResizeObserver(() => {
  boxPanel.update()
})

onMounted(() => {
  // Attach box panel to DOM:
  Widget.attach(boxPanel, mainDiv.value)
  // Watch for resize of the main element to trigger relayout:
  resizeObserver.observe(mainDiv.value)
  $eventBus.on('add-view', addView)
  getLayout(props.workflowName)
})

onBeforeUnmount(() => {
  resizeObserver.disconnect()
  $eventBus.off('add-view', addView)
  saveLayout()
  // Register with Lumino that the dock panel is no longer used,
  // otherwise uncaught errors can occur when restoring layout
  dockPanel.dispose()
})

/**
 * Create a widget and add it to the dock.
 *
 * @param {AddViewEvent} event
 * @param {boolean} onTop
 */
const addView = ({ name, initialOptions = {} }, onTop = true) => {
  const id = uniqueId('widget')
  const luminoWidget = new LuminoWidget(id, startCase(name), /* closable */ true)
  dockPanel.addWidget(luminoWidget, { mode: 'tab-after' })
  // give time for Lumino's widget DOM element to be created
  nextTick(() => {
    views.value.set(id, { name, initialOptions })
    addWidgetEventListeners(id)
    if (onTop) {
      dockPanel.selectWidget(luminoWidget)
    }
  })
}

/**
 * Remove all the widgets present in the DockPanel.
 */
const closeAllViews = () => {
  for (const widget of Array.from(dockPanel.widgets())) {
    widget.close()
  }
}

/**
 * Get the saved layout (if there is one) for the given workflow,
 * else add the default view.
 *
 * @param {string} workflowName
 */
const getLayout = (workflowName) => {
  restoreLayout(workflowName) || addView({ name: defaultView.value })
}

/**
 * Save the current layout/views to the store.
 */
const saveLayout = () => {
  $store.commit('app/saveLayout', {
    workflowName: props.workflowName,
    layout: dockPanel.saveLayout(),
    views: new Map(views.value),
  })
}

/**
 * Restore the layout for this workflow from the store, if it was saved.
 *
 * @param {string} workflowName
 * @returns {boolean} true if the layout was restored, false otherwise
 */
const restoreLayout = (workflowName) => {
  const stored = $store.state.app.workspaceLayouts.get(workflowName)
  if (stored) {
    dockPanel.restoreLayout(stored.layout)
    // Wait for next tick so that Lumino has created the widget divs that the
    // views will be teleported into
    nextTick(() => {
      views.value = stored.views
      for (const id of views.value.keys()) {
        addWidgetEventListeners(id)
      }
    })
    return true
  }
  return false
}

/**
 * Save & close the current layout and open the one for the given workflow.
 *
 * @param {string} workflowName
 */
const changeLayout = (workflowName) => {
  saveLayout()
  closeAllViews()
  // Wait if necessary for the workflowName prop to be updated to the new value:
  when(
    () => props.workflowName === workflowName,
    () => getLayout(workflowName),
  )
}

/**
 * @param {string} id - widget ID
 */
const addWidgetEventListeners = (id) => {
  const widgetEl = document.getElementById(id)
  widgetEl.addEventListener('lumino:deleted', onWidgetDeleted)
  // widgetEl.addEventListener('lumino:activated', this.onWidgetActivated)
}

/**
 * React to a deleted event.
 *
 * @param {{
 *   detail: {
 *     id: string,
 *     name: string,
 *     closable: boolean
 *   }
 * }} customEvent
 */
const onWidgetDeleted = (customEvent) => {
  const { id } = customEvent.detail
  views.value.delete(id)
  const widgetEl = document.getElementById(id)
  widgetEl.removeEventListener('lumino:deleted', onWidgetDeleted)
  // widgetEl.removeEventListener('lumino:activated', this.onWidgetActivated)
  if (!views.value.size) {
    emit('emptied')
  }
}

defineExpose({
  changeLayout,
})
</script>
